---
layout: post
title:  "栈"
date:   2014-07-02 11:41:23
categories: jekyll update
---
##栈

大部分程序员相信对StackOverFlow.com这个网站不会感到陌生，其中Stack就是栈，栈是一种先进后出的结构，这种结构在计算机架构中很经常使用到，特别是在线程回调的过程中会用到。结合上一个提到的链表LinkedNode，我们这里构建一个泛型的栈，在英文翻译和中文翻译中，经常是多个名词对应一个英文单词，因此也会给初学者带来一些误解，有一些人可能觉得堆栈和栈不是一个概念，但是就目前的资料来看，堆栈就是栈，这里稍作提醒。

以下是泛型栈的结构：
<pre>
<code>
package edu.handos.interview.structure;

/**
 * Created by jimmylee on 6/18/14.
 */
public class Stack<T extends LinkedNode>{
    /**
     * 栈顶
     */
    private T top;


    /** 
     * 获取栈顶部
     * @return
     */
    public T getTop()
    {
        if(top!=null)
        {
            return top;
        }
        return null;
    }

    /**
     * 入栈
     * @param item
     */
    public void push(T item)
    {
        if(item!=null)
        {
            if(top==null)
            {
                top=item;
            }else
            {
                item.setNext(top);
                top=item;
            }
        }
    }

    /**
     * 出栈
     * @return
     */
    public T pop()
    {
        T item=top;
        top=(T)top.getNext();
        return item;
    }


}

</code>
</pre>

测试代码
<pre>
<code>
public static void stackTestMain()
    {
        Stack<LinkedNode> linkedNodeStack=new Stack<LinkedNode>();
        linkedNodeStack.push(new LinkedNode("很好，我是第一个进去的人"));
        linkedNodeStack.push(new LinkedNode("很好，我是第二个进去的人"));
        System.out.println("有一个人出了栈:"+linkedNodeStack.pop().getNodeName());
        System.out.println("又一个人出了栈:"+linkedNodeStack.pop().getNodeName());

    }
</code>
</pre>

##队列

队列非常好理解，简单的就是排队。队列的特别就是先进先出，谁排在最前面总是最有优势，可惜在中国，你很少能够见到严格按照队列的思想来执行的排队等待。
同样是实现代码和测试代码如下:
<pre>
<code>
package edu.handos.interview.structure;

/**
 * Created by jimmylee on 6/18/14.
 */
public class Queue<T extends LinkedNode> {

    private T first=null;
    private T last=null;
    /**
     * 入队列
     * @param item
     */
    public void inEnqueue(T item)
    {
        if(first==null)
        {
            first=item;
            last=item;
        }else
        {
            last.setNext(item);
            last=item;
        }



    }

    /**
     * 出队列
     * @return
     */
    public T outEnqueue()
    {
        T item=first;
        first=(T)first.getNext();
        return item;
    }
}

</code>
</pre>

<pre>
<code>
 public static void queueTestMain()
    {
        Queue<LinkedNode> linkedNodeQueue=new Queue<LinkedNode>();
        linkedNodeQueue.inEnqueue(new LinkedNode("很好，我是第一个排队的人"));
        linkedNodeQueue.inEnqueue(new LinkedNode("很好，我是第二个排队的人"));
        System.out.println("有一个人出了队列:"+linkedNodeQueue.outEnqueue().getNodeName());
        System.out.println("又一个人出了队列:"+linkedNodeQueue.outEnqueue().getNodeName());
    }
</code>
</pre>
